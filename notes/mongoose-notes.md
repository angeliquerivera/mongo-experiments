# Mongoose

## What is Mongoose?

- It is a library(module) that allows you model objects for MongoDB in JS

## What is a schema?

- Schema" refers to an organizational blueprint of how a DB and its collections are put together.
- A subschema is good to have when the parent schema will have nested data that itself is plentiful. It may not be necessary to define a subschema if the nested data is only a few simple fields.

## What is a model?

- A model is a fancy constructor compiled from schema definitions.
- An instance of a model is called a document.
- Models are responsible for creating and reading documents from the underlying MongoDB database.
- When you call `mongoose.model()` on a schema, Mongoose complies a model for you.

### How is a schema used in the creating and updating of documents?

- When you try to create/update a document, Mongoose/MongoDB will refer to the schema that you have defined to see if the data fields and corresponding values are valid as defined by the attribute validators in the schema.

## What is `_id` on a Mongo document object?

- `_id` is the UNIQUE identifier that is generated by MongoDB at document creation time.

## What is `__v` on a Mongo document object?

- `__v` is MongoDB's internal document version tracker. It incre--ents whenever the specific document object(s) is/are updated.

## `mongoose.SchemaTypes.ObjectId`

- This field is a reference to another document's `ObjectId`.

- **In a MongoDB collection, not all document objects need to have all the same fields.**

- When it comes to document field errors, by defining the types in the schema, you can catch errors when a document field type doesn't match the defined schema.

## What is a `try-catch` block?

- A `try-catch block` is what you use when you have asynchronous operations to attempt a certain operation and catch exceptions if they're thrown.
  - In the try-block, it'll try to do stuff. If the stuff in the try-block fails, the catch-block will return whatever error the try operation produced.

## Document Field Attribute Validation

### Transformations

- In addition to requiring fields, you can transform them based on their type.

```js
const someSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    lowercase: true, // emails are case insensitive
    // ANGE@HOLOLIVE.TV -> ange@hololive.tv
  },
});
```

### Defaults

- You can dictate default values if a field is not assigned at the time of document creation.

```js
{
  createdAt: {
    type: Date,
    default: () => Date.now(), // runs if this value is not assigned at creation time
  },
}
```

### Immutability

- "Immutable" means unable to be changed. Once the value exists, it's permanent; it can never be changed. It takes the key `immutable` and it accepts the boolean `true`.

### Minimums and Maximums

#### Numbers

### Custom Validation

- Custom validators are objects that contain a `validator` key-function pair and a `message` key-string pair.

## MongoDB methods and validation; a warning

### Manual `.save()`

```js
async function run() {
  const idol2 = new Idol({ name: "Mori Calliope", height: 167 });
  await idol2.save(); // <-- .save() will use the pre-defined schema validation
  console.log(idol2);
}
run();
```

### `Model.create()`

```js
async function run() {
  const idol2 = await Idol.create({ name: "Mori Calliope", height: 167 });

  idol2.name = "Houshou Marine";
  idol2.save();
  // .create() is a mongoose Model method that will use pre-defined schema validation
}
```

## Document querying

- For single document queries, if you want to search for a specific single document using it's `_id`, use `.findById()`. This method will return a single document if found and `null` if the document is not found.

- If you're searching for a single document that matches a certain criteria, use `.findOne()`. `.findOne()` returns the matching document. It returns `null` if the document is not found.

- To find out whether or not a document exists that matches the given criteria, use `.exists()`. `.exists()` returns a boolean: `true` if exists, `false` if it does not exist.

- To delete one of the documents created that matches the given criteria, use `.deleteOne()`. `.deleteOne()` returns an object with the key `deletedCount` and value of how many documents were deleted. A value of 0 will be returned if the document does not exist.

- Mongoose models provide several static helper functions for CRUD operations. Each of these functions returns a mongoose `Query` object.

  - `Model.deleteMany()`
  - `Model.deleteOne()`
  - `Model.find()`
  - `Model.findById()`
  - `Model.findByIdAndDelete()`
  - `Model.findByIdAndRemove()`
  - `Model.findByIdAndUpdate()`
  - `Model.findOne()`
  - `Model.findOneAndDelete()`
  - `Model.findOneAndRemove()`
  - `Model.findOneAndReplace()`
  - `Model.findOneAndUpdate()`
  - `Model.replaceOne()`
  - `Model.updateMany()`
  - `Model.updateOne()`

## `.where()` Queries

- `.where()` queries are very similar to `.find()` with the key difference being we can chain the query methods.

```js
const usingWhere = await Idol.where("name").equals("Mori Calliope"); //example of chaining methods for single query
```

```js
const usingWhere = await Idol.where("name")
  .equals("Mori Calliope")
  .where("subcount")
  .equals(1890000); //chaining for multiple queries
```

- `.gt()` is "greater than" method and `.lt()` is "less than" method

## Manually updating an existing document

- difference between outputs of `.find` and `.findOne` and `.where`

  - `.where()` and `.find()` are generic searches and therefore output a collection of data aka arrays of objects (documents).
  - `.findOne()` outputs a specific query result therefore returns the first matching document object.

- how and when `.save()` is applied

  - When you update a document manually, you must use `.save()` to save the information manually.
    - `.save()` is an asynchronous function that needs `await` in order to run properly.

## `.populate()`

- `.populate()` is a method that allows you to combine/JOIN data based off of references existing on one or more documents into a returned set of data.
- `.populate()` does not modify the populated data entries.
- the populate method allows databases to remain small by using document references across the database for query-time data combinations.

### Schema must-haves

- When you have a field that you can populate on, you need to ensure that that field also contains a `ref key` refering to the model name to use the `ObjectId` to search on.

## Schema methods

- You can add different methods and functionalites directly to the schema so that you can access different data based on these customized functions.
- Schema methods are ways to add methods to schema the same way that we would add instance methods to classes in `Idol.js`.

### Frame of reference

- `this`: the document(s)

## Static methods

- Static methods DO NOT work on instances. Instead, they work directly on the model.

### Frame of reference

- `this`: the Model

## Chainable methods

- We can add methods that ONLY operate on queries you run to the schema.

### Frame of reference

- `this`: the Query

## Virtual methods

- Virtual methods are named and they use getters and setters just like Classes can, so they are not invoked. The virtual method itself is not a function, rather its getter/setter is.
- Virtual methods don't change anything but they do help in gathering data (similar to `.populate()`).
- Virtual methods are the simplest ways to compose new data from existing document fields.

### Frame of reference

- `this`: the document(s)

## Schema Middleware

- Similar to Express Middleware where it allows you to run code inbetween actions. There is Middleware that covers saving, validating, updating and removing (specific to document functions).

### Middleware hooks

- Works off of methods call `pre` and `post`. They provide the framework for the middleware to happen.
